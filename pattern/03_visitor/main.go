package main

import "fmt"

//Паттерн "Посетитель" (Visitor) позволяет добавлять новые операции к объектам без изменения этих объектов.
//Он отделяет алгоритмы от структуры данных, на которых они оперируют, предоставляя способ для реализации
//операций над элементами объекта структуры.
//
//Применимость
//Когда необходимо добавить новые операции к объектам без изменения их классов: паттерн "Посетитель" позволяет
//добавлять новые методы к объектам без изменения их исходного кода.
//Когда нужно выполнить различные и несвязанные операции над объектами: паттерн позволяет
//разделить несвязанные операции на разные классы посетителей.
//Когда структура объекта редко изменяется, но операции над объектами часто изменяются: паттерн удобен,
//когда добавление новых операций к объектам происходит чаще, чем изменение самих объектов.
//Плюсы
//Упрощение добавления новых операций: легко добавлять новые операции, не изменяя классы объектов.
//Разделение алгоритмов: позволяет отделить алгоритмы от структуры данных, улучшая модульность и читаемость кода.
//Повторное использование кода: операции могут быть повторно использованы для различных объектов.
//Минусы
//Изменение объектов: добавление новых типов объектов требует изменения классов посетителей.
//Сложность кода: могут возникнуть трудности при проектировании и понимании паттерна, особенно в больших системах.
//Реальные примеры использования
//Компиляторы: используют посетителей для выполнения операций на абстрактных синтаксических деревьях (AST),
//таких как генерация кода, анализ и оптимизация.
//Графические редакторы: применяют посетителей для выполнения операций над графическими элементами,
//такими как рендеринг, преобразования и сохранение.
//Базы данных: используют посетителей для выполнения различных операций на элементах данных,
//таких как индексация, агрегация и фильтрация.

// Visitor - интерфейс посетителя
type Visitor interface {
	VisitElementA(*ElementA)
	VisitElementB(*ElementB)
}

// Element - интерфейс элемента
type Element interface {
	Accept(Visitor)
}

// ElementA - конкретный элемент A
type ElementA struct {
	Value string
}

func (e *ElementA) Accept(v Visitor) {
	v.VisitElementA(e)
}

// ElementB - конкретный элемент B
type ElementB struct {
	Number int
}

func (e *ElementB) Accept(v Visitor) {
	v.VisitElementB(e)
}

// ConcreteVisitor1 - конкретный посетитель 1
type ConcreteVisitor1 struct{}

func (v *ConcreteVisitor1) VisitElementA(e *ElementA) {
	fmt.Printf("ConcreteVisitor1: обработка ElementA со значением: %s\n", e.Value)
}

func (v *ConcreteVisitor1) VisitElementB(e *ElementB) {
	fmt.Printf("ConcreteVisitor1: обработка ElementB со значением: %d\n", e.Number)
}

// ConcreteVisitor2 - конкретный посетитель 2
type ConcreteVisitor2 struct{}

func (v *ConcreteVisitor2) VisitElementA(e *ElementA) {
	fmt.Printf("ConcreteVisitor2: преобразование ElementA со значением: %s\n", e.Value)
}

func (v *ConcreteVisitor2) VisitElementB(e *ElementB) {
	fmt.Printf("ConcreteVisitor2: удвоение числа ElementB: %d\n", e.Number*2)
}

func main() {
	elements := []Element{
		&ElementA{Value: "Hello"},
		&ElementB{Number: 42},
	}

	visitor1 := &ConcreteVisitor1{}
	visitor2 := &ConcreteVisitor2{}

	for _, e := range elements {
		e.Accept(visitor1)
		e.Accept(visitor2)
	}
}
