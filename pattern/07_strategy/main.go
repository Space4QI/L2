package main

import "fmt"

//Паттерн "Стратегия" позволяет определить семейство алгоритмов, инкапсулировать каждый из них и сделать их
//взаимозаменяемыми. Это позволяет выбирать алгоритм во время выполнения, обеспечивая гибкость и возможность
//легко менять поведение программы.
//
//Применимость
//Когда нужно использовать разные вариации алгоритма внутри одного объекта: паттерн позволяет легко менять
//алгоритмы в зависимости от условий.
//Когда есть множество родственных классов, которые отличаются поведением: вместо создания множества
//подклассов для каждого варианта поведения, можно использовать стратегии.
//Когда необходимо скрыть сложные, условно-зависимые алгоритмы: паттерн помогает инкапсулировать алгоритмы,
//улучшая читаемость и поддержку кода.
//Плюсы
//Замена алгоритмов на лету: паттерн позволяет менять алгоритмы во время выполнения, обеспечивая
//гибкость и адаптивность.
//Изолирование алгоритмов: каждый алгоритм инкапсулирован в свой собственный класс, что упрощает
//тестирование и отладку.
//Принцип открытости/закрытости: новые алгоритмы могут быть добавлены без изменения существующего кода.
//Минусы
//Усложнение кода из-за увеличения числа классов: каждый алгоритм требует создания отдельного класса,
//что может увеличить количество классов в проекте.
//Необходимость использования дополнительных объектов: клиентский код должен знать о стратегии и
//использовать её, что может усложнить интерфейс.
//Реальные примеры использования
//Сортировка данных: паттерн используется для выбора различных алгоритмов сортировки
//(быстрая сортировка, сортировка вставками, сортировка слиянием) в зависимости от типа данных и их объёма.
//Шифрование данных: стратегии шифрования позволяют выбирать различные алгоритмы шифрования
//(AES, RSA, DES) в зависимости от требований безопасности.
//Расчёт стоимости доставки: в электронной коммерции стратегии могут использоваться для расчёта
//стоимости доставки различными способами (по весу, по расстоянию, фиксированная ставка).

// Strategy - интерфейс стратегии
type Strategy interface {
	Execute(a, b int) int
}

// Addition - конкретная стратегия для сложения
type Addition struct{}

func (Addition) Execute(a, b int) int {
	return a + b
}

// Subtraction - конкретная стратегия для вычитания
type Subtraction struct{}

func (Subtraction) Execute(a, b int) int {
	return a - b
}

// Multiplication - конкретная стратегия для умножения
type Multiplication struct{}

func (Multiplication) Execute(a, b int) int {
	return a * b
}

// Context - контекст, использующий стратегию
type Context struct {
	strategy Strategy
}

func (c *Context) SetStrategy(strategy Strategy) {
	c.strategy = strategy
}

func (c *Context) ExecuteStrategy(a, b int) int {
	return c.strategy.Execute(a, b)
}

func main() {
	context := &Context{}

	// Используем стратегию сложения
	context.SetStrategy(Addition{})
	fmt.Println("10 + 5 =", context.ExecuteStrategy(10, 5))

	// Используем стратегию вычитания
	context.SetStrategy(Subtraction{})
	fmt.Println("10 - 5 =", context.ExecuteStrategy(10, 5))

	// Используем стратегию умножения
	context.SetStrategy(Multiplication{})
	fmt.Println("10 * 5 =", context.ExecuteStrategy(10, 5))
}
