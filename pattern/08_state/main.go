package main

import "fmt"

//Паттерн "Состояние" позволяет объекту изменять свое поведение при изменении внутреннего состояния.
//Это структурный паттерн, который локализует состояние в отдельных классовых структурах, позволяет
//изменять поведение объекта в зависимости от его состояния.
//
//Применимость
//Когда поведение объекта должно зависеть от его состояния и может изменяться во время выполнения: паттерн
//позволяет изменять поведение объекта динамически.
//Когда код содержит множество условных операторов, которые зависят от состояния объекта: паттерн заменяет
//условные операторы на вызовы методов объектов состояния.
//Плюсы
//Избавление от множества условных операторов: паттерн устраняет большие блоки условных операторов,
//что улучшает читаемость и поддержку кода.
//Инкапсуляция состояния: каждое состояние инкапсулируется в отдельном классе, что упрощает добавление
//новых состояний и изменение существующих.
//Упрощение добавления новых состояний: новые состояния можно легко добавить, создав новый класс состояния,
//не изменяя существующий код.
//Минусы
//Увеличение количества классов: паттерн может привести к увеличению количества классов в проекте,
//так как каждое состояние требует создания отдельного класса.
//Необходимость изменения контекста при добавлении новых состояний: иногда может потребоваться изменение
//контекста для поддержки новых состояний.
//Реальные примеры использования
//Автоматический переключатель режимов в видеоиграх: персонаж может быть в состоянии ходьбы, бега или прыжка,
//и поведение персонажа изменяется в зависимости от текущего состояния.
//Автоматическое управление режимами работы в электронике: например, телевизор может быть в состоянии
//включения, выключения, ожидания или работы.
//Потоковые обработчики в веб-приложениях: обработчик запросов может находиться в различных состояниях
//(готов, обрабатывает запрос, завершает обработку), и его поведение изменяется в зависимости от состояния.

// State - интерфейс состояния
type State interface {
	Handle(context *Context)
}

// ConcreteStateA - конкретное состояние A
type ConcreteStateA struct{}

func (s *ConcreteStateA) Handle(context *Context) {
	fmt.Println("Состояние A: Переход к состоянию B")
	context.SetState(&ConcreteStateB{})
}

// ConcreteStateB - конкретное состояние B
type ConcreteStateB struct{}

func (s *ConcreteStateB) Handle(context *Context) {
	fmt.Println("Состояние B: Переход к состоянию A")
	context.SetState(&ConcreteStateA{})
}

// Context - контекст, использующий состояние
type Context struct {
	state State
}

func (c *Context) SetState(state State) {
	c.state = state
}

func (c *Context) Request() {
	c.state.Handle(c)
}

func main() {
	context := &Context{}

	// Установка начального состояния A
	context.SetState(&ConcreteStateA{})

	// Выполнение запроса, который меняет состояние2
	context.Request()

	// Выполнение следующего запроса, который снова меняет состояние
	context.Request()
}
