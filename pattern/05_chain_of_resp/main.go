package main

import "fmt"

//Паттерн "Цепочка обязанностей" позволяет избежать жесткой привязки отправителя запроса к его получателю,
//давая возможность нескольким объектам обработать запрос. Эти объекты связаны в цепочку, и запрос передается
//по цепочке, пока один из объектов не обработает его.
//
//Применимость
//Когда необходимо отправить запрос одному из нескольких объектов, определённых во время выполнения:
//цепочка обязанностей позволяет динамически определять обработчик запроса.
//Когда требуется избежать жесткой привязки отправителя запроса к его получателю: паттерн устраняет
//зависимость отправителя запроса от его конечного обработчика.
//Когда необходимо передавать запрос последовательно через цепочку объектов: паттерн позволяет
//организовать последовательное прохождение запроса через набор потенциальных обработчиков.
//Плюсы
//Снижение зависимости между отправителем и получателем запроса: паттерн позволяет изменять цепочку
//обработчиков без изменения отправителя запроса.
//Гибкость в добавлении новых обработчиков: новые обработчики могут быть легко добавлены в цепочку.
//Упрощение расширения и поддержки кода: Цепочка позволяет организовать обработку запросов в более
//модульном и расширяемом виде.
//Минусы
//Нет гарантии обработки запроса: запрос может остаться необработанным, если ни один из объектов
//цепочки не сможет его обработать.
//Усложнение отладки: отладка может стать сложнее из-за необходимости отслеживать прохождение
//запроса через цепочку обработчиков.
//Реальные примеры использования
//Обработка событий в пользовательском интерфейсе: цепочка обязанностей используется для обработки событий,
//таких как нажатие клавиш или нажатие кнопок, в последовательности компонентов интерфейса.
//Логирование: паттерн используется для организации цепочки логгирования,
//где каждый элемент цепочки отвечает за определенный уровень логирования (отладка, информация, ошибка).
//Обработка заявок и форм: в бизнес-приложениях паттерн применяется
//для последовательной обработки заявок или форм, где каждый этап цепочки выполняет определенную проверку или
//обработку.

// Handler - интерфейс обработчика
type Handler interface {
	SetNext(Handler) Handler
	Handle(request string)
}

// BaseHandler - базовый обработчик, реализующий метод SetNext
type BaseHandler struct {
	next Handler
}

func (h *BaseHandler) SetNext(next Handler) Handler {
	h.next = next
	return next
}

func (h *BaseHandler) Handle(request string) {
	if h.next != nil {
		h.next.Handle(request)
	}
}

// HandlerA - конкретный обработчик A
type HandlerA struct {
	BaseHandler
}

func (h *HandlerA) Handle(request string) {
	if request == "A" {
		fmt.Println("HandlerA обработал запрос:", request)
	} else {
		h.BaseHandler.Handle(request)
	}
}

// HandlerB - конкретный обработчик B
type HandlerB struct {
	BaseHandler
}

func (h *HandlerB) Handle(request string) {
	if request == "B" {
		fmt.Println("HandlerB обработал запрос:", request)
	} else {
		h.BaseHandler.Handle(request)
	}
}

func main() {
	handlerA := &HandlerA{}
	handlerB := &HandlerB{}

	handlerA.SetNext(handlerB)

	requests := []string{"A", "B", "C"}

	for _, req := range requests {
		fmt.Printf("Обработка запроса: %s\n", req)
		handlerA.Handle(req)
	}
}
